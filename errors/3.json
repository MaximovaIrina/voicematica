{"update_id": 942109867, "message": {"message_id": 1337, "from": {"id": 413997438, "is_bot": false, "first_name": "Михаил", "username": "Mievst", "language_code": "ru"}, "chat": {"id": 413997438, "first_name": "Михаил", "username": "Mievst", "type": "private"}, "date": 1684150982, "text": "Python имеет встроенный профилировщик (cProfile), но в данном случае это неподходящий инструмент для работы:\n\nОн навесит большую трату ресурсов на весь код на Python, но не увеличит нагрузку на нативный код, поэтому результаты могут оказаться искажёнными.\nМы не сможем просматривать нативные кадры, то есть не сможем заглянуть в наш код на Rust.\n\nМы будем использовать py-spy (GitHub).\n\npy-spy — это сэмплирующий профилировщик, способный заглядывать в нативные кадры.\n\nРазработчики также любезно опубликовали готовые wheel для pypi, поэтому можно просто ввести pip install py-spy и приступать к работе.\n\nЕщё нам нужно что-то для измерений.\n\n# measure.py\nimport time\nimport poly_match\nimport os\n \n# Снижаем шум, в нашем случае повышая производительность.\nos.environ[\"OPENBLAS_NUM_THREADS\"] = \"1\"\n\npolygons, points = poly_match.generate_example()\n\n# Мы будем увеличивать это значение, когда наш код будет становиться всё быстрее и быстрее.\nNUM_ITER = 10\n\nt0 = time.perf_counter()\nfor _ in range(NUM_ITER):\n    poly_match.main(polygons, points)\nt1 = time.perf_counter()\n\ntook = (t1 - t0) / NUM_ITER\nprint(f\"Took and avg of {took * 1000:.2f}ms per iteration\")\n\nВыглядит не очень научно, но позволит нам сделать огромный шаг вперёд.\n\n«Хороший бенчмаркинг — это сложно. Тем не менее — не слишком налегайте на создание идеальной системы бенчмаркинга, особенно когда вы начинаете оптимизировать программу». ~ Николас Нетеркот, «The Rust Performance Book»\n\nПосле выполнения этого скрипта мы получим результаты, от которых можно отталкиваться:\n\n$ python measure.py\nTook an avg of 293.41ms per iteration\n\nДля нашей настоящей библиотеки мы использовали 50 разных случаев, чтобы гарантировать покрытие всех случаев.\n\nЭто соответствовало общей производительности системы, то есть мы могли приступать к борьбе с этими числами.\n\nПримечание: можно также выполнять измерения при помощи PyPy (также мы добавим разогрев, чтобы JIT показала свою магию).\n\n$ conda create -n pypyenv -c conda-forge pypy numpy && conda activate pypyenv\n$ pypy measure_with_warmup.py\nTook an avg of 1495.81ms per iteration\n\n▍ Измерения — это главное\n\nТак, давайте выясним, что же тут так медленно работает.\n\n$ py-spy record --native -o profile.svg -- python measure.py\npy-spy> Sampling process 100 times a second. Press Control-C to exit.\n\nTook an avg of 365.43ms per iteration\n\npy-spy> Stopped sampling because process exited\npy-spy> Wrote flamegraph data to 'profile.svg'. Samples: 391 Errors: 0\n\nМы уже видим, что лишняя трата ресурсов тут довольно мала. Просто для сравнения, при использовании cProfile мы получим следующее:\n\n$ python -m cProfile measure.py\nTook an avg of 546.47ms per iteration\n         7551778 function calls (7409483 primitive calls) in 7.806 seconds\n         ...\n\nМы получаем вот такой красивый красный график, называемый flamegraph:\n\n\n\nКаждый прямоугольник — это функция. В оригинале статьи график интерактивен и мы можем видеть относительное время, проводимое в каждой функции, в том числе в функциях, которые она вызывает (спускаясь вниз по графику/стеку). Попробуйте нажать на прямоугольник norm, чтобы приблизить его.\n\nЗдесь можно сделать следующие основные выводы:\n\nПодавляющее большинство времени тратится в find_close_polygons.\nОсновная часть этого времени тратится на выполнение norm, которая является функцией numpy.\n\nИтак, давайте взглянем на find_close_polygons:\n\ndef find_close_polygons(\n    polygon_subset: List[Polygon], point: np.array, max_dist: float\n) -> List[Polygon]:\n    close_polygons = []\n    for poly in polygon_subset:\n        if np.linalg.norm(poly.center - point) < max_dist:\n            close_polygons.append(poly)\n\n    return close_polygons\n\nМы перепишем эту функцию на Rust.\n\nПрежде чем вдаваться в подробности, важно заметить здесь несколько моментов:\n\nЭта функция принимает и возвращает сложные объекты (Polygon, np.array).\nРазмер объектов нетривиален (поэтому копирование может быть затратным).\nЭта функция вызывается часто (поэтому внесённая нами лишняя трата ресурсов, вероятно, будет иметь значение).\n\n▍ Мой первый модуль Rust", "entities": [{"offset": 643, "length": 10, "type": "url"}, {"offset": 1544, "length": 10, "type": "url"}, {"offset": 2216, "length": 10, "type": "url"}, {"offset": 2609, "length": 10, "type": "url"}, {"offset": 3554, "length": 11, "type": "url"}]}}