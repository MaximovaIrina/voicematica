{"update_id": 942109868, "message": {"message_id": 1338, "from": {"id": 413997438, "is_bot": false, "first_name": "Михаил", "username": "Mievst", "language_code": "ru"}, "chat": {"id": 413997438, "first_name": "Михаил", "username": "Mievst", "type": "private"}, "date": 1684150982, "text": "pyo3 — это крейт для взаимодействия между Python и Rust. Он имеет чрезвычайно хорошую документацию, а базовая настройка объяснена здесь.\n\nМы назовём свой крейт poly_match_rs и добавим функцию find_close_polygons.\n\nmkdir poly_match_rs && cd \"$_\"\npip install maturin\nmaturin init --bindings pyo3\nmaturin develop\n\nИзначально наш крейт будет выглядеть так:\n\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn find_close_polygons() -> PyResult<()> {\n    Ok(())\n}\n\n#[pymodule]\nfn poly_match_rs(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(find_close_polygons, m)?)?;\n    Ok(())\n}\n\nНам также нужно не забывать выполнять maturin develop каждый раз, когда мы меняем библиотеку Rust.\n\nВот и всё! Давайте вызовем нашу новую функцию и посмотрим, что произойдёт.\n\n>>> poly_match_rs.find_close_polygons(polygons, point, max_dist)\nE TypeError: poly_match_rs.poly_match_rs.find_close_polygons() takes no arguments (3 given)\n\n▍ v1 — наивная трансляция Rust\n\nНачнём мы с сопоставления ожидаемого API.\n\nPyO3 довольно сообразителен при преобразованиях из Python в Rust, поэтому это будет достаточно просто:\n\n#[pyfunction]\nfn find_close_polygons(polygons: Vec<PyObject>, point: PyObject, max_dist: f64) -> PyResult<Vec<PyObject>> {\n    Ok(vec![])\n}\n\nPyObject — это (как понятно из имени) обобщённый объект Python. Мы попробуем немного повзаимодействовать с ним.\n\nЭто должно заставить программу выполняться (хоть и некорректно).\n\nЯ просто скопирую и вставлю исходную функцию на Python, а потом исправлю синтаксис.\n\n#[pyfunction]\nfn find_close_polygons(polygons: Vec<PyObject>, point: PyObject, max_dist: f64) -> PyResult<Vec<PyObject>> {\n    let mut close_polygons = vec![];\n    \n    for poly in polygons {\n        if norm(poly.center - point) < max_dist {\n            close_polygons.push(poly)\n        }\n    }\n    \n    Ok(close_polygons)\n}\n\nЗдорово, но это не компилируется:\n\n% maturin develop\n...\n\nerror[E0609]: no field center on type Py<PyAny>\n --> src/lib.rs:8:22\n  |\n8 |         if norm(poly.center - point) < max_dist {\n  |                      ^^^^^^ unknown field\n\n\nerror[E0425]: cannot find function norm in this scope\n --> src/lib.rs:8:12\n  |\n8 |         if norm(poly.center - point) < max_dist {\n  |            ^^^^ not found in this scope\n\n\nerror: aborting due to 2 previous errors ] 58/59: poly_match_rs\n\nДля реализации этой функции нам потребуются три крейта:\n\n# Для нативных операций с массивами Rust.\nndarray = \"0.15\"\n\n# Для функции \"norm\" для массивов.\nndarray-linalg = \"0.16\"  \n\n# Для доступа к созданным numpy объектам, основанным на \"ndarray\".\nnumpy = \"0.18\"\n\nДля начала давайте превратим непрозрачную и обобщённую point: PyObject во что-то, с чем мы сможем работать.\n\nТочно так же, как мы попросили у PyO3 Vec объекта PyObject, мы можем попросить numpy-array, и он автоматически преобразует аргумент.\n\nuse numpy::PyReadonlyArray1;\n\n#[pyfunction]\nfn find_close_polygons(\n    // Объект, говорящий \"У меня есть GIL\", чтобы мы могли получить доступ к управляемой Python памяти.\n    py: Python<'_>,\n    polygons: Vec<PyObject>,\n    // Ссылка на массив numpy, доступ к которой мы сможем иметь.\n    point: PyReadonlyArray1<f64>,\n    max_dist: f64,\n) -> PyResult<Vec<PyObject>> {\n    // Преобразуем в полнофункциональный нативный массив \"ndarray::ArrayView1\".\n    let point = point.as_array();\n    ...\n}\n\nТак как точка теперь находится в ArrayView1, мы можем её использовать. Например:\n\n// делаем доступной функцию \"norm\".\nuse ndarray_linalg::Norm;\n\nassert_eq!((point.to_owned() - point).norm(), 0.);\n\nТеперь нам просто нужно получить центр каждого многоугольника и преобразовать его в ArrayView1.\n\nНа PyO3 это выглядит так:\n\nlet center = poly\n  .getattr(py, \"center\")?                 // getattr в стиле Python, требует токен GIL (py).\n  .extract::<PyReadonlyArray1<f64>>(py)?  // Сообщаем PyO3, во что преобразовать результат.\n  .as_array()                             // Как \"point\" ранее.\n  .to_owned();                            // Нам нужно, чтобы одной из сторон - \"владели\".", "entities": [{"offset": 1726, "length": 11, "type": "url"}, {"offset": 1926, "length": 6, "type": "code"}, {"offset": 1941, "length": 9, "type": "code"}, {"offset": 1960, "length": 8, "type": "url"}, {"offset": 1996, "length": 11, "type": "url"}, {"offset": 2113, "length": 4, "type": "code"}, {"offset": 2141, "length": 8, "type": "url"}, {"offset": 2177, "length": 11, "type": "url"}, {"offset": 3749, "length": 2, "type": "code"}, {"offset": 3988, "length": 1, "type": "code"}]}}