{"update_id": 942109869, "message": {"message_id": 1339, "from": {"id": 413997438, "is_bot": false, "first_name": "Михаил", "username": "Mievst", "language_code": "ru"}, "chat": {"id": 413997438, "first_name": "Михаил", "username": "Mievst", "type": "private"}, "date": 1684150982, "text": "Слегка многословно, но в целом результат, очевидно, является построчной трансляцией первоначального кода:\n\nuse pyo3::prelude::*;\n\nuse ndarray_linalg::Norm;\nuse numpy::PyReadonlyArray1;\n\n#[pyfunction]\nfn find_close_polygons(\n    py: Python<'_>,\n    polygons: Vec<PyObject>,\n    point: PyReadonlyArray1<f64>,\n    max_dist: f64,\n) -> PyResult<Vec<PyObject>> {\n    let mut close_polygons = vec![];\n    let point = point.as_array();\n    for poly in polygons {\n        let center = poly\n            .getattr(py, \"center\")?\n            .extract::<PyReadonlyArray1<f64>>(py)?\n            .as_array()\n            .to_owned();\n\n        if (center - point).norm() < max_dist {\n            close_polygons.push(poly)\n        }\n    }\n\n    Ok(close_polygons)\n}\n\nСравним с оригиналом:\n\ndef find_close_polygons(\n    polygon_subset: List[Polygon], point: np.array, max_dist: float\n) -> List[Polygon]:\n    close_polygons = []\n    for poly in polygon_subset:\n        if np.linalg.norm(poly.center - point) < max_dist:\n            close_polygons.append(poly)\n\n    return close_polygons\n\nМы ожидаем, что эта версия будет иметь преимущества перед исходной функцией, но насколько?\n\n$ (cd ./poly_match_rs/ && maturin develop)\n$ python measure.py\nTook an avg of 609.46ms per iteration\n\nТо есть… Rust очень медленный? Нет! Мы просто забыли узнать скорость! Если запустим код с maturin develop --release, то получим результаты гораздо лучше:\n\n$ (cd ./poly_match_rs/ && maturin develop --release)\n$ python measure.py\nTook an avg of 23.44ms per iteration\n\nА вот это уже хорошее ускорение!\n\nТакже мы хотим иметь возможность заглядывать в нативный код, поэтому включим отладочные символы в релизе. И заодно спросим максимальную скорость.\n\n# added to Cargo.toml\n[profile.release]\ndebug = true       # Отладочные символы для нашего профилировщика.\nlto = true         # Оптимизация этапа компоновки.\ncodegen-units = 1  # Более медленная компиляция, зато более быстрый код. \n\n▍ v2 — перепишем ещё больше на Rust\n\nТеперь использовав флаг --native в py-spy, мы сможем видеть и Python, и наш новый нативный код.\n\nСнова запускаем py-spy:\n\n$ py-spy record --native -o profile.svg -- python measure.py\npy-spy> Sampling process 100 times a second. Press Control-C to exit.\n\nПолучаем такой flamegraph (некрасные цвета добавлены для того, чтобы мы могли отталкиваться от них):\n\nИнтерактивную версию можно посмотреть здесь\n\nПосмотрев на вывод профилировщика, мы можем заметить несколько интересных моментов:\n\nОтносительный размер find_close_polygons::...::trampoline (символа, который Python непосредственно вызывает) и __pyfunction_find_close_polygons (нашей реализации).\nЕсли навести мышь, видно, что сэмплы соотносятся как 95% и 88%, то есть лишняя трата ресурсов довольно мала.\nСама логика (if (center - point).norm() < max_dist { ... }), которая находится в lib_v1.rs:22 (очень маленький прямоугольник справа), занимает примерно 9% от всего времени исполнения.\nТо есть улучшение в десять раз всё равно должно быть возможно!\nОсновная часть времени тратится на lib_v1.rs:16, то есть на poly.getattr(...).extract(...), и если мы приблизим изображение, то увидим, что на самом деле это просто getattr и получение внутреннего массива при помощи as_array.\n\nМожно сделать вывод, что нам нужно сосредоточиться на решении третьего пункта, и сделать это можно Переписав Polygon на Rust.\n\nДавайте взглянем на нашу цель:\n\n@dataclass\nclass Polygon:\n    x: np.array\n    y: np.array\n    _area: float = None\n\n    @cached_property\n    def center(self) -> np.array:\n        centroid = np.array([self.x, self.y]).mean(axis=1)\n        return centroid\n\n    def area(self) -> float:\n        if self._area is None:\n            self._area = 0.5 * np.abs(\n                np.dot(self.x, np.roll(self.y, 1)) - np.dot(self.y, np.roll(self.x, 1))\n            )\n        return self._area\n\nНам нужно максимально сохранить имеющийся API, но нам не нужно (пока), чтобы area была такой уж быстрой.\n\nСам класс может содержать дополнительные сложные вещи, например, метод merge, использующий ConvexHull из scipy.spatial.", "entities": [{"offset": 965, "length": 11, "type": "url"}, {"offset": 1210, "length": 10, "type": "url"}, {"offset": 1477, "length": 10, "type": "url"}, {"offset": 2149, "length": 10, "type": "url"}, {"offset": 3369, "length": 10, "type": "mention"}, {"offset": 3456, "length": 16, "type": "mention"}, {"offset": 3706, "length": 6, "type": "url"}, {"offset": 3743, "length": 6, "type": "url"}]}}