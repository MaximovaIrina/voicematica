{"update_id": 942109871, "message": {"message_id": 1341, "from": {"id": 413997438, "is_bot": false, "first_name": "Михаил", "username": "Mievst", "language_code": "ru"}, "chat": {"id": 413997438, "first_name": "Михаил", "username": "Mievst", "type": "private"}, "date": 1684150982, "text": "Мы начинаем видеть select_best_polygon, которая теперь вызывает какой-то код на Rust (когда получает векторы x и y)\nМожно это исправить, но потенциал этого улучшения очень мал (возможно, 10%)\nМы видим, что тратим примерно 20% времени в extract_argument (в lib_v2.rs:48), то есть лишняя трата ресурсов по-прежнему довольно велика!\nНо бОльшая часть времени тратится на PyIterator::next и PyTypeInfo::is_type_of, что исправить не так просто.\nМы видим, что довольно много времени тратится на распределение!\nlib_v2.rs:58 — это наш if, и мы видим drop_in_place и to_owned.\nВсего это около 35% от суммарного времени, что гораздо больше, чем мы ожидали: при наличии всех данных это должна быть быстрая часть кода.\n\nДавайте разберёмся с последним пунктом.\n\nВот фрагмент кода, вызывающий проблемы:\n\nlet center = poly.borrow(py).center\n    .to_owned();\n\nif (center - point).norm() < max_dist { ... } \n\nМы хотим избежать вот этого to_owned. Но нам нужен owned-объект для norm, поэтому придётся реализовать его вручную.\n\n(Причина того, что мы можем улучшить ndarray, заключается в том, что мы знаем, что наш массив на самом деле представляет собой два значения f32).\n\nЭто будет выглядеть так:\n\nuse ndarray_linalg::Scalar;\n\nlet center = &poly.as_ref(py).borrow().center;\n\nif ((center[0] - point[0]).square() + (center[1] - point[1]).square()).sqrt() < max_dist {\n    close_polygons.push(poly)\n}\n\nНо, увы, borrow checker нами недоволен:\n\nerror[E0505]: cannot move out of poly because it is borrowed\n  --> src/lib.rs:58:33\n   |\n55 |         let center = &poly.as_ref(py).borrow().center;\n   |                       ------------------------\n   |                       |\n   |                       borrow of poly occurs here\n   |                       a temporary with access to the borrow is created here ...\n...\n58 |             close_polygons.push(poly);\n   |                                 ^^^^ move out of poly occurs here\n59 |         }\n60 |     }\n   |     - ... and the borrow might be used here, when that temporary is dropped and runs the Drop code for type PyRef\n\nКак обычно, borrow checker прав: мы совершаем преступления с памятью.\n\nПроще всего исправить это при помощи Just Clone, после чего close_polygons.push(poly.clone()) скомпилируется.\n\nНа самом деле, это очень малозатратный клон, потому что мы всего лишь выполняем incr счётчика ссылок объекта Python.\n\nОднако в этом случае мы можем сократить borrow, сделав классический трюк Rust:\n\nlet norm = {\n    let center = &poly.as_ref(py).borrow().center;\n\n    ((center[0] - point[0]).square() + (center[1] - point[1]).square()).sqrt()\n};\n\nif norm < max_dist {\n    close_polygons.push(poly)\n}\n\nТак как poly заимствуется только во внутренней области видимости, после того как мы достигнем close_polygons.push, компилятор сможет узнать, что мы больше не храним эту ссылку и спокойно скомпилирует новую версию.\n\nНаконец, мы добились следующего:\n\n$ python measure.py\nTook an avg of 2.90ms per iteration\n\nСтократное улучшение по сравнению с первоначальным кодом.\n\n▍ Подведение итогов\n\nМы начинали с такого кода на Python:\n\n@dataclass\nclass Polygon:\n    x: np.array\n    y: np.array\n    _area: float = None\n\n    @cached_property\n    def center(self) -> np.array:\n        centroid = np.array([self.x, self.y]).mean(axis=1)\n        return centroid\n\n    def area(self) -> float:\n        ...\n\ndef find_close_polygons(\n    polygon_subset: List[Polygon], point: np.array, max_dist: float\n) -> List[Polygon]:\n    close_polygons = []\n    for poly in polygon_subset:\n        if np.linalg.norm(poly.center - point) < max_dist:\n            close_polygons.append(poly)\n\n    return close_polygons\n\n# Остальная часть файла (main, select_best_polygon).\n\nМы профилировали его при помощи py-spy, и даже самая наивная построчная трансляция find_close_polygons обеспечила улучшение в десять с лишним раз.\n\nМы выполнили несколько дополнительных итераций «профилирование-написание кода-измерения», пока не получили стократное улучшение времени исполнения, сохранив при этом тот же API, что и у исходной библиотеки.", "entities": [{"offset": 1456, "length": 4, "type": "code"}, {"offset": 1494, "length": 9, "type": "url"}, {"offset": 1690, "length": 4, "type": "code"}, {"offset": 1894, "length": 4, "type": "code"}, {"offset": 2031, "length": 4, "type": "code"}, {"offset": 2050, "length": 5, "type": "code"}, {"offset": 2897, "length": 10, "type": "url"}, {"offset": 3063, "length": 10, "type": "mention"}, {"offset": 3150, "length": 16, "type": "mention"}, {"offset": 3522, "length": 11, "type": "url"}]}}