{"update_id": 942109872, "message": {"message_id": 1343, "from": {"id": 413997438, "is_bot": false, "first_name": "Михаил", "username": "Mievst", "language_code": "ru"}, "chat": {"id": 413997438, "first_name": "Михаил", "username": "Mievst", "type": "private"}, "date": 1684150982, "text": "Версия  Ср. время на итерацию (мс)  Множитель\nБазовая реализация (на Python)  293,41  1x\nНаивная построчная трансляция на Rust find_close_polygons  23,44  12,50x\nРеализация Polygon на Rust  6,29  46,53x\nОптимизированная реализация распределений на Rust  2,90  101,16x\nОкончательный код на Python выглядит так:\n\nimport poly_match_rs\nfrom poly_match_rs import find_close_polygons\n\nclass Polygon(poly_match_rs.Polygon):\n    _area: float = None\n\n    def area(self) -> float:\n        ...\n\n# Оставшаяся часть файла не изменилась (main, select_best_polygon).\n\nОн вызывает следующий код на Rust:\n\nuse pyo3::prelude::*;\n\nuse ndarray::Array1;\nuse ndarray_linalg::Scalar;\nuse numpy::{PyArray1, PyReadonlyArray1, ToPyArray};\n\n#[pyclass(subclass)]\nstruct Polygon {\n    x: Array1<f64>,\n    y: Array1<f64>,\n    center: Array1<f64>,\n}\n\n#[pymethods]\nimpl Polygon {\n    #[new]\n    fn new(x: PyReadonlyArray1<f64>, y: PyReadonlyArray1<f64>) -> Polygon {\n        let x = x.as_array();\n        let y = y.as_array();\n        let center = Array1::from_vec(vec![x.mean().unwrap(), y.mean().unwrap()]);\n\n        Polygon {\n            x: x.to_owned(),\n            y: y.to_owned(),\n            center,\n        }\n    }\n\n    #[getter]\n    fn x(&self, py: Python<'_>) -> PyResult<Py<PyArray1<f64>>> {\n        Ok(self.x.to_pyarray(py).to_owned())\n    }\n\n    // То же для \"y\" и \"center\".\n}\n\n#[pyfunction]\nfn find_close_polygons(\n    py: Python<'_>,\n    polygons: Vec<Py<Polygon>>,\n    point: PyReadonlyArray1<f64>,\n    max_dist: f64,\n) -> PyResult<Vec<Py<Polygon>>> {\n    let mut close_polygons = vec![];\n    let point = point.as_array();\n    for poly in polygons {\n        let norm = {\n            let center = &poly.as_ref(py).borrow().center;\n\n            ((center[0] - point[0]).square() + (center[1] - point[1]).square()).sqrt()\n        };\n\n        if norm < max_dist {\n            close_polygons.push(poly)\n        }\n    }\n\n    Ok(close_polygons)\n}\n\n#[pymodule]\nfn poly_match_rs(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Polygon>()?;\n    m.add_function(wrap_pyfunction!(find_close_polygons, m)?)?;\n    Ok(())\n}\n\n▍ Выводы\n\nRust (при помощи pyo3) раскрывает истинную нативную производительность повседневного кода на Python с минимальными компромиссами.\nPython — превосходный API для исследователей, а создание быстрых строительных блоков на Rust — это чрезвычайно мощное сочетание.\nПрофилирование крайне интересно, оно мотивирует по-настоящему разобраться со всем, что происходит в вашем коде.\n\nИ последнее: компьютеры безумно быстры. Когда вам в следующий раз нужно будет что-то сделать, попробуйте запустить профилировщик, возможно, вы научитесь чему-то новому."}}